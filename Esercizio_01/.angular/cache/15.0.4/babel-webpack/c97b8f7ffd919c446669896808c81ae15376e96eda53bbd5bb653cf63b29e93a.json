{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst q = require(\"q\");\nconst util = require(\"util\");\nconst exitCodes_1 = require(\"../exitCodes\");\nconst logger_1 = require(\"../logger\");\nconst driverProvider_1 = require(\"./driverProvider\");\nconst BrowserstackClient = require('browserstack');\nlet logger = new logger_1.Logger('browserstack');\nclass BrowserStack extends driverProvider_1.DriverProvider {\n  constructor(config) {\n    super(config);\n  }\n  /**\n   * Hook to update the BrowserStack job status.\n   * @public\n   * @param {Object} update\n   * @return {q.promise} A promise that will resolve when the update is complete.\n   */\n  updateJob(update) {\n    let deferredArray = this.drivers_.map(driver => {\n      let deferred = q.defer();\n      driver.getSession().then(session => {\n        // Fetching BrowserStack session details.\n        this.browserstackClient.getSession(session.getId(), function (error, automate_session) {\n          if (error) {\n            logger.info('BrowserStack results available at ' + 'https://www.browserstack.com/automate');\n          } else {\n            if (automate_session && automate_session.browser_url) {\n              logger.info('BrowserStack results available at ' + automate_session.browser_url);\n            } else {\n              logger.info('BrowserStack results available at ' + 'https://www.browserstack.com/automate');\n            }\n          }\n        });\n        let jobStatus = update.passed ? 'completed' : 'error';\n        let statusObj = {\n          status: jobStatus\n        };\n        // Updating status of BrowserStack session.\n        this.browserstackClient.updateSession(session.getId(), statusObj, function (error, automate_session) {\n          if (error) {\n            throw new exitCodes_1.BrowserError(logger, 'Error updating BrowserStack pass/fail status: ' + util.inspect(error));\n          } else {\n            logger.info(automate_session);\n            deferred.resolve();\n          }\n        });\n      });\n      return deferred.promise;\n    });\n    return q.all(deferredArray);\n  }\n  /**\n   * Configure and launch (if applicable) the object's environment.\n   * @return {q.promise} A promise which will resolve when the environment is\n   *     ready to test.\n   */\n  setupDriverEnv() {\n    let deferred = q.defer();\n    this.config_.capabilities['browserstack.user'] = this.config_.browserstackUser;\n    this.config_.capabilities['browserstack.key'] = this.config_.browserstackKey;\n    this.config_.seleniumAddress = 'http://hub.browserstack.com/wd/hub';\n    this.browserstackClient = BrowserstackClient.createAutomateClient({\n      username: this.config_.browserstackUser,\n      password: this.config_.browserstackKey,\n      proxy: this.config_.browserstackProxy\n    });\n    // Append filename to capabilities.name so that it's easier to identify\n    // tests.\n    if (this.config_.capabilities.name && this.config_.capabilities.shardTestFiles) {\n      this.config_.capabilities.name += ':' + this.config_.specs.toString().replace(/^.*[\\\\\\/]/, '');\n    }\n    logger.info('Using BrowserStack selenium server at ' + this.config_.seleniumAddress);\n    deferred.resolve();\n    return deferred.promise;\n  }\n}\nexports.BrowserStack = BrowserStack;\n//# sourceMappingURL=browserStack.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}