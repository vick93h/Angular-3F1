{"ast":null,"code":"/*!\n * Tmp\n *\n * Copyright (c) 2011-2015 KARASZI Istvan <github@spam.raszi.hu>\n *\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\nvar fs = require('fs'),\n  path = require('path'),\n  crypto = require('crypto'),\n  tmpDir = require('os-tmpdir'),\n  _c = process.binding('constants');\n\n/**\n * The working inner variables.\n */\nvar\n  // store the actual TMP directory\n  _TMP = tmpDir(),\n  // the random characters to choose from\n  RANDOM_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n  TEMPLATE_PATTERN = /XXXXXX/,\n  DEFAULT_TRIES = 3,\n  CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR),\n  DIR_MODE = 448 /* 0700 */,\n  FILE_MODE = 384 /* 0600 */,\n  // this will hold the objects need to be removed on exit\n  _removeObjects = [],\n  _gracefulCleanup = false,\n  _uncaughtException = false;\n\n/**\n * Random name generator based on crypto.\n * Adapted from http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript\n *\n * @param {Number} howMany\n * @return {String}\n * @api private\n */\nfunction _randomChars(howMany) {\n  var value = [],\n    rnd = null;\n\n  // make sure that we do not fail because we ran out of entropy\n  try {\n    rnd = crypto.randomBytes(howMany);\n  } catch (e) {\n    rnd = crypto.pseudoRandomBytes(howMany);\n  }\n  for (var i = 0; i < howMany; i++) {\n    value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);\n  }\n  return value.join('');\n}\n\n/**\n * Checks whether the `obj` parameter is defined or not.\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\nfunction _isUndefined(obj) {\n  return typeof obj === 'undefined';\n}\n\n/**\n * Parses the function arguments.\n *\n * This function helps to have optional arguments.\n *\n * @param {Object} options\n * @param {Function} callback\n * @api private\n */\nfunction _parseArguments(options, callback) {\n  if (typeof options == 'function') {\n    var tmp = options,\n      options = callback || {},\n      callback = tmp;\n  } else if (typeof options == 'undefined') {\n    options = {};\n  }\n  return [options, callback];\n}\n\n/**\n * Generates a new temporary name.\n *\n * @param {Object} opts\n * @returns {String}\n * @api private\n */\nfunction _generateTmpName(opts) {\n  if (opts.name) {\n    return path.join(opts.dir || _TMP, opts.name);\n  }\n\n  // mkstemps like template\n  if (opts.template) {\n    return opts.template.replace(TEMPLATE_PATTERN, _randomChars(6));\n  }\n\n  // prefix and postfix\n  var name = [opts.prefix || 'tmp-', process.pid, _randomChars(12), opts.postfix || ''].join('');\n  return path.join(opts.dir || _TMP, name);\n}\n\n/**\n * Gets a temporary file name.\n *\n * @param {Object} options\n * @param {Function} callback\n * @api private\n */\nfunction _getTmpName(options, callback) {\n  var args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1],\n    tries = opts.tries || DEFAULT_TRIES;\n  if (isNaN(tries) || tries < 0) return cb(new Error('Invalid tries'));\n  if (opts.template && !opts.template.match(TEMPLATE_PATTERN)) return cb(new Error('Invalid template provided'));\n  (function _getUniqueName() {\n    var name = _generateTmpName(opts);\n\n    // check whether the path exists then retry if needed\n    fs.stat(name, function (err) {\n      if (!err) {\n        if (tries-- > 0) return _getUniqueName();\n        return cb(new Error('Could not get a unique tmp filename, max tries reached ' + name));\n      }\n      cb(null, name);\n    });\n  })();\n}\n\n/**\n * Synchronous version of _getTmpName.\n *\n * @param {Object} options\n * @returns {String}\n * @api private\n */\nfunction _getTmpNameSync(options) {\n  var args = _parseArguments(options),\n    opts = args[0],\n    tries = opts.tries || DEFAULT_TRIES;\n  if (isNaN(tries) || tries < 0) throw new Error('Invalid tries');\n  if (opts.template && !opts.template.match(TEMPLATE_PATTERN)) throw new Error('Invalid template provided');\n  do {\n    var name = _generateTmpName(opts);\n    try {\n      fs.statSync(name);\n    } catch (e) {\n      return name;\n    }\n  } while (tries-- > 0);\n  throw new Error('Could not get a unique tmp filename, max tries reached');\n}\n\n/**\n * Creates and opens a temporary file.\n *\n * @param {Object} options\n * @param {Function} callback\n * @api public\n */\nfunction _createTmpFile(options, callback) {\n  var args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n  opts.postfix = _isUndefined(opts.postfix) ? '.tmp' : opts.postfix;\n\n  // gets a temporary filename\n  _getTmpName(opts, function _tmpNameCreated(err, name) {\n    if (err) return cb(err);\n\n    // create and open the file\n    fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err, fd) {\n      if (err) return cb(err);\n      cb(null, name, fd, _prepareTmpFileRemoveCallback(name, fd, opts));\n    });\n  });\n}\n\n/**\n * Synchronous version of _createTmpFile.\n *\n * @param {Object} options\n * @returns {Object} object consists of name, fd and removeCallback\n * @api private\n */\nfunction _createTmpFileSync(options) {\n  var args = _parseArguments(options),\n    opts = args[0];\n  opts.postfix = opts.postfix || '.tmp';\n  var name = _getTmpNameSync(opts);\n  var fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);\n  return {\n    name: name,\n    fd: fd,\n    removeCallback: _prepareTmpFileRemoveCallback(name, fd, opts)\n  };\n}\n\n/**\n * Removes files and folders in a directory recursively.\n *\n * @param {String} root\n * @api private\n */\nfunction _rmdirRecursiveSync(root) {\n  var dirs = [root];\n  do {\n    var dir = dirs.pop(),\n      deferred = false,\n      files = fs.readdirSync(dir);\n    for (var i = 0, length = files.length; i < length; i++) {\n      var file = path.join(dir, files[i]),\n        stat = fs.lstatSync(file); // lstat so we don't recurse into symlinked directories\n\n      if (stat.isDirectory()) {\n        if (!deferred) {\n          deferred = true;\n          dirs.push(dir);\n        }\n        dirs.push(file);\n      } else {\n        fs.unlinkSync(file);\n      }\n    }\n    if (!deferred) {\n      fs.rmdirSync(dir);\n    }\n  } while (dirs.length !== 0);\n}\n\n/**\n * Creates a temporary directory.\n *\n * @param {Object} options\n * @param {Function} callback\n * @api public\n */\nfunction _createTmpDir(options, callback) {\n  var args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  // gets a temporary filename\n  _getTmpName(opts, function _tmpNameCreated(err, name) {\n    if (err) return cb(err);\n\n    // create the directory\n    fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err) {\n      if (err) return cb(err);\n      cb(null, name, _prepareTmpDirRemoveCallback(name, opts));\n    });\n  });\n}\n\n/**\n * Synchronous version of _createTmpDir.\n *\n * @param {Object} options\n * @returns {Object} object consists of name and removeCallback\n * @api private\n */\nfunction _createTmpDirSync(options) {\n  var args = _parseArguments(options),\n    opts = args[0];\n  var name = _getTmpNameSync(opts);\n  fs.mkdirSync(name, opts.mode || DIR_MODE);\n  return {\n    name: name,\n    removeCallback: _prepareTmpDirRemoveCallback(name, opts)\n  };\n}\n\n/**\n * Prepares the callback for removal of the temporary file.\n *\n * @param {String} name\n * @param {int} fd\n * @param {Object} opts\n * @api private\n * @returns {Function} the callback\n */\nfunction _prepareTmpFileRemoveCallback(name, fd, opts) {\n  var removeCallback = _prepareRemoveCallback(function _removeCallback(fdPath) {\n    try {\n      fs.closeSync(fdPath[0]);\n    } catch (e) {\n      // under some node/windows related circumstances, a temporary file\n      // may have not be created as expected or the file was already closed\n      // by the user, in which case we will simply ignore the error\n      if (e.errno != -(_c.EBADF || _c.os.errno.EBADF) && e.errno != -(_c.ENOENT || _c.os.errno.ENOENT)) {\n        // reraise any unanticipated error\n        throw e;\n      }\n    }\n    fs.unlinkSync(fdPath[1]);\n  }, [fd, name]);\n  if (!opts.keep) {\n    _removeObjects.unshift(removeCallback);\n  }\n  return removeCallback;\n}\n\n/**\n * Prepares the callback for removal of the temporary directory.\n *\n * @param {String} name\n * @param {Object} opts\n * @returns {Function} the callback\n * @api private\n */\nfunction _prepareTmpDirRemoveCallback(name, opts) {\n  var removeFunction = opts.unsafeCleanup ? _rmdirRecursiveSync : fs.rmdirSync.bind(fs);\n  var removeCallback = _prepareRemoveCallback(removeFunction, name);\n  if (!opts.keep) {\n    _removeObjects.unshift(removeCallback);\n  }\n  return removeCallback;\n}\n\n/**\n * Creates a guarded function wrapping the removeFunction call.\n *\n * @param {Function} removeFunction\n * @param {Object} arg\n * @returns {Function}\n * @api private\n */\nfunction _prepareRemoveCallback(removeFunction, arg) {\n  var called = false;\n  return function _cleanupCallback() {\n    if (called) return;\n    var index = _removeObjects.indexOf(_cleanupCallback);\n    if (index >= 0) {\n      _removeObjects.splice(index, 1);\n    }\n    called = true;\n    removeFunction(arg);\n  };\n}\n\n/**\n * The garbage collector.\n *\n * @api private\n */\nfunction _garbageCollector() {\n  if (_uncaughtException && !_gracefulCleanup) {\n    return;\n  }\n\n  // the function being called removes itself from _removeObjects,\n  // loop until _removeObjects is empty\n  while (_removeObjects.length) {\n    try {\n      _removeObjects[0].call(null);\n    } catch (e) {\n      // already removed?\n    }\n  }\n}\nfunction _setGracefulCleanup() {\n  _gracefulCleanup = true;\n}\nvar version = process.versions.node.split('.').map(function (value) {\n  return parseInt(value, 10);\n});\nif (version[0] === 0 && (version[1] < 9 || version[1] === 9 && version[2] < 5)) {\n  process.addListener('uncaughtException', function _uncaughtExceptionThrown(err) {\n    _uncaughtException = true;\n    _garbageCollector();\n    throw err;\n  });\n}\nprocess.addListener('exit', function _exit(code) {\n  if (code) _uncaughtException = true;\n  _garbageCollector();\n});\n\n// exporting all the needed methods\nmodule.exports.tmpdir = _TMP;\nmodule.exports.dir = _createTmpDir;\nmodule.exports.dirSync = _createTmpDirSync;\nmodule.exports.file = _createTmpFile;\nmodule.exports.fileSync = _createTmpFileSync;\nmodule.exports.tmpName = _getTmpName;\nmodule.exports.tmpNameSync = _getTmpNameSync;\nmodule.exports.setGracefulCleanup = _setGracefulCleanup;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}