{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst http = require(\"http\");\nconst url = require(\"url\");\nconst webdriver_commands_1 = require(\"./webdriver_commands\");\n/**\n * A proxy that understands WebDriver commands. Users can add barriers (similar to middleware in\n * express) that will be called before forwarding the request to WebDriver. The proxy will wait for\n * each barrier to finish, calling them in the order in which they were added.\n */\nclass WebDriverProxy {\n  constructor(seleniumAddress) {\n    this.barriers = [];\n    this.seleniumAddress = seleniumAddress;\n  }\n  addBarrier(barrier) {\n    this.barriers.push(barrier);\n  }\n  handleRequest(originalRequest, response) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let command = webdriver_commands_1.parseWebDriverCommand(originalRequest.url, originalRequest.method);\n      let replyWithError = err => {\n        response.writeHead(502);\n        if (err && err.toString) {\n          response.write(err.toString());\n        }\n        response.end();\n      };\n      // Process barriers in order, one at a time.\n      try {\n        for (let barrier of this.barriers) {\n          yield barrier.onCommand(command);\n        }\n      } catch (err) {\n        replyWithError(err);\n        // Don't call through if a barrier fails.\n        return;\n      }\n      let parsedUrl = url.parse(this.seleniumAddress);\n      let options = {};\n      options.method = originalRequest.method;\n      options.path = parsedUrl.path + originalRequest.url;\n      options.hostname = parsedUrl.hostname;\n      options.port = parseInt(parsedUrl.port);\n      options.headers = originalRequest.headers;\n      let forwardedRequest = http.request(options);\n      // clang-format off\n      let reqData = '';\n      originalRequest.on('data', d => {\n        reqData += d;\n        forwardedRequest.write(d);\n      }).on('end', () => {\n        command.handleData(reqData);\n        forwardedRequest.end();\n      }).on('error', replyWithError);\n      forwardedRequest.on('response', seleniumResponse => {\n        response.writeHead(seleniumResponse.statusCode, seleniumResponse.headers);\n        let respData = '';\n        seleniumResponse.on('data', d => {\n          respData += d;\n          response.write(d);\n        }).on('end', () => {\n          command.handleResponse(seleniumResponse.statusCode, respData);\n          response.end();\n        }).on('error', replyWithError);\n      }).on('error', replyWithError);\n      // clang-format on\n    });\n  }\n}\n\nexports.WebDriverProxy = WebDriverProxy;\n//# sourceMappingURL=webdriver_proxy.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}