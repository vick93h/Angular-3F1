{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\n *  This is an implementation of the Direct Driver Provider.\n *  It is responsible for setting up the account object, tearing\n *  it down, and setting up the driver correctly.\n */\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst q = require(\"q\");\nconst selenium_webdriver_1 = require(\"selenium-webdriver\");\nconst chrome_1 = require(\"selenium-webdriver/chrome\");\nconst exitCodes_1 = require(\"../exitCodes\");\nconst logger_1 = require(\"../logger\");\nconst driverProvider_1 = require(\"./driverProvider\");\nconst SeleniumConfig = require('webdriver-manager/built/lib/config').Config;\nlet logger = new logger_1.Logger('direct');\nclass Direct extends driverProvider_1.DriverProvider {\n  constructor(config) {\n    super(config);\n  }\n  /**\n   * Configure and launch (if applicable) the object's environment.\n   * @return {q.promise} A promise which will resolve when the environment is\n   *     ready to test.\n   */\n  setupDriverEnv() {\n    switch (this.config_.capabilities.browserName) {\n      case 'chrome':\n        logger.info('Using ChromeDriver directly...');\n        break;\n      case 'firefox':\n        logger.info('Using FirefoxDriver directly...');\n        break;\n      default:\n        throw new exitCodes_1.BrowserError(logger, 'browserName ' + this.config_.capabilities.browserName + ' is not supported with directConnect.');\n    }\n    return q.fcall(function () {});\n  }\n  /**\n   * Create a new driver.\n   *\n   * @public\n   * @override\n   * @return webdriver instance\n   */\n  getNewDriver() {\n    let driver;\n    switch (this.config_.capabilities.browserName) {\n      case 'chrome':\n        let chromeDriverFile;\n        if (this.config_.chromeDriver) {\n          chromeDriverFile = this.config_.chromeDriver;\n        } else {\n          try {\n            let updateJson = path.resolve(SeleniumConfig.getSeleniumDir(), 'update-config.json');\n            let updateConfig = JSON.parse(fs.readFileSync(updateJson).toString());\n            chromeDriverFile = updateConfig.chrome.last;\n          } catch (e) {\n            throw new exitCodes_1.BrowserError(logger, 'Could not find update-config.json. ' + 'Run \\'webdriver-manager update\\' to download binaries.');\n          }\n        }\n        if (!fs.existsSync(chromeDriverFile)) {\n          throw new exitCodes_1.BrowserError(logger, 'Could not find chromedriver at ' + chromeDriverFile + '. Run \\'webdriver-manager update\\' to download binaries.');\n        }\n        let chromeService = new chrome_1.ServiceBuilder(chromeDriverFile).build();\n        // driver = ChromeDriver.createSession(new Capabilities(this.config_.capabilities),\n        // chromeService);\n        // TODO(ralphj): fix typings\n        driver = require('selenium-webdriver/chrome').Driver.createSession(new selenium_webdriver_1.Capabilities(this.config_.capabilities), chromeService);\n        break;\n      case 'firefox':\n        let geckoDriverFile;\n        if (this.config_.geckoDriver) {\n          geckoDriverFile = this.config_.geckoDriver;\n        } else {\n          try {\n            let updateJson = path.resolve(SeleniumConfig.getSeleniumDir(), 'update-config.json');\n            let updateConfig = JSON.parse(fs.readFileSync(updateJson).toString());\n            geckoDriverFile = updateConfig.gecko.last;\n          } catch (e) {\n            throw new exitCodes_1.BrowserError(logger, 'Could not find update-config.json. ' + 'Run \\'webdriver-manager update\\' to download binaries.');\n          }\n        }\n        if (!fs.existsSync(geckoDriverFile)) {\n          throw new exitCodes_1.BrowserError(logger, 'Could not find geckodriver at ' + geckoDriverFile + '. Run \\'webdriver-manager update\\' to download binaries.');\n        }\n        // TODO (mgiambalvo): Turn this into an import when the selenium typings are updated.\n        const FirefoxServiceBuilder = require('selenium-webdriver/firefox').ServiceBuilder;\n        let firefoxService = new FirefoxServiceBuilder(geckoDriverFile).build();\n        // TODO(mgiambalvo): Fix typings.\n        driver = require('selenium-webdriver/firefox').Driver.createSession(new selenium_webdriver_1.Capabilities(this.config_.capabilities), firefoxService);\n        break;\n      default:\n        throw new exitCodes_1.BrowserError(logger, 'browserName ' + this.config_.capabilities.browserName + ' is not supported with directConnect.');\n    }\n    this.drivers_.push(driver);\n    return driver;\n  }\n}\nexports.Direct = Direct;\n//# sourceMappingURL=direct.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}