{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst glob = require(\"glob\");\nconst path = require(\"path\");\nconst exitCodes_1 = require(\"./exitCodes\");\nconst logger_1 = require(\"./logger\");\nlet logger = new logger_1.Logger('configParser');\n// Coffee is required here to enable config files written in coffee-script.\ntry {\n  require('coffee-script').register();\n} catch (e) {\n  // Intentionally blank - ignore if coffee-script is not available.\n}\n// CoffeeScript lost the hyphen in the module name a long time ago, all new version are named this:\ntry {\n  require('coffeescript').register();\n} catch (e) {\n  // Intentionally blank - ignore if coffeescript is not available.\n}\n// LiveScript is required here to enable config files written in LiveScript.\ntry {\n  require('LiveScript');\n} catch (e) {\n  // Intentionally blank - ignore if LiveScript is not available.\n}\nclass ConfigParser {\n  constructor() {\n    // Default configuration.\n    this.config_ = {\n      specs: [],\n      multiCapabilities: [],\n      verboseMultiSessions: false,\n      rootElement: '',\n      allScriptsTimeout: 11000,\n      getPageTimeout: 10000,\n      params: {},\n      framework: 'jasmine',\n      jasmineNodeOpts: {\n        showColors: true,\n        defaultTimeoutInterval: 30 * 1000\n      },\n      seleniumArgs: [],\n      mochaOpts: {\n        ui: 'bdd',\n        reporter: 'list'\n      },\n      configDir: './',\n      noGlobals: false,\n      plugins: [],\n      skipSourceMapSupport: false,\n      ng12Hybrid: false\n    };\n  }\n  /**\n   * Resolve a list of file patterns into a list of individual file paths.\n   *\n   * @param {Array.<string> | string} patterns\n   * @param {=boolean} opt_omitWarnings Whether to omit did not match warnings\n   * @param {=string} opt_relativeTo Path to resolve patterns against\n   *\n   * @return {Array} The resolved file paths.\n   */\n  static resolveFilePatterns(patterns, opt_omitWarnings, opt_relativeTo) {\n    let resolvedFiles = [];\n    let cwd = opt_relativeTo || process.cwd();\n    patterns = typeof patterns === 'string' ? [patterns] : patterns;\n    if (patterns) {\n      for (let fileName of patterns) {\n        let matches = glob.hasMagic(fileName) ? glob.sync(fileName, {\n          cwd\n        }) : [fileName];\n        if (!matches.length && !opt_omitWarnings) {\n          logger.warn('pattern ' + fileName + ' did not match any files.');\n        }\n        for (let match of matches) {\n          let resolvedPath = path.resolve(cwd, match);\n          resolvedFiles.push(resolvedPath);\n        }\n      }\n    }\n    return resolvedFiles;\n  }\n  /**\n   * Returns only the specs that should run currently based on `config.suite`\n   *\n   * @return {Array} An array of globs locating the spec files\n   */\n  static getSpecs(config) {\n    let specs = [];\n    if (config.suite) {\n      config.suite.split(',').forEach(suite => {\n        let suiteList = config.suites ? config.suites[suite] : null;\n        if (suiteList == null) {\n          throw new exitCodes_1.ConfigError(logger, 'Unknown test suite: ' + suite);\n        }\n        union(specs, makeArray(suiteList));\n      });\n      return specs;\n    }\n    if (config.specs.length > 0) {\n      return config.specs;\n    }\n    Object.keys(config.suites || {}).forEach(suite => {\n      union(specs, makeArray(config.suites[suite]));\n    });\n    return specs;\n  }\n  /**\n   * Add the options in the parameter config to this runner instance.\n   *\n   * @private\n   * @param {Object} additionalConfig\n   * @param {string} relativeTo the file path to resolve paths against\n   */\n  addConfig_(additionalConfig, relativeTo) {\n    // All filepaths should be kept relative to the current config location.\n    // This will not affect absolute paths.\n    ['seleniumServerJar', 'chromeDriver', 'firefoxPath', 'frameworkPath', 'geckoDriver', 'onPrepare'].forEach(name => {\n      if (additionalConfig[name] && typeof additionalConfig[name] === 'string') {\n        additionalConfig[name] = path.resolve(relativeTo, additionalConfig[name]);\n      }\n    });\n    merge_(this.config_, additionalConfig);\n  }\n  /**\n   * Public function specialized towards merging in a file's config\n   *\n   * @public\n   * @param {String} filename\n   */\n  addFileConfig(filename) {\n    if (!filename) {\n      return this;\n    }\n    let filePath = path.resolve(process.cwd(), filename);\n    let fileConfig;\n    try {\n      fileConfig = require(filePath).config;\n    } catch (e) {\n      throw new exitCodes_1.ConfigError(logger, 'failed loading configuration file ' + filename, e);\n    }\n    if (!fileConfig) {\n      throw new exitCodes_1.ConfigError(logger, 'configuration file ' + filename + ' did not export a config object');\n    }\n    fileConfig.configDir = path.dirname(filePath);\n    this.addConfig_(fileConfig, fileConfig.configDir);\n    return this;\n  }\n  /**\n   * Public function specialized towards merging in config from argv\n   *\n   * @public\n   * @param {Object} argv\n   */\n  addConfig(argv) {\n    this.addConfig_(argv, process.cwd());\n    return this;\n  }\n  /**\n   * Public getter for the final, computed config object\n   *\n   * @public\n   * @return {Object} config\n   */\n  getConfig() {\n    return this.config_;\n  }\n}\nexports.ConfigParser = ConfigParser;\n/**\n * Merge config objects together.\n *\n * @private\n * @param {Object} into\n * @param {Object} from\n *\n * @return {Object} The 'into' config.\n */\nlet merge_ = function (into, from) {\n  for (let key in from) {\n    if (into[key] instanceof Object && !(into[key] instanceof Array) && !(into[key] instanceof Function)) {\n      merge_(into[key], from[key]);\n    } else {\n      into[key] = from[key];\n    }\n  }\n  return into;\n};\n/**\n * Returns the item if it's an array or puts the item in an array\n * if it was not one already.\n */\nlet makeArray = function (item) {\n  return Array.isArray(item) ? item : [item];\n};\n/**\n * Adds to an array all the elements in another array without adding any\n * duplicates\n *\n * @param {string[]} dest The array to add to\n * @param {string[]} src The array to copy from\n */\nlet union = function (dest, src) {\n  let elems = {};\n  for (let key in dest) {\n    elems[dest[key]] = true;\n  }\n  for (let key in src) {\n    if (!elems[src[key]]) {\n      dest.push(src[key]);\n      elems[src[key]] = true;\n    }\n  }\n};\n//# sourceMappingURL=configParser.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}